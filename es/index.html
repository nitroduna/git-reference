---
layout: es_reference
---
<div class="box">
  <h2>Introducción a la Guía de Referencia de Git</h2>
  <div class="block">
    <p>
    Este es el sitio web de la Guía de Referencia de Git. La finalidad de este sitio web 
    es servir como guía de referencia rápida para el aprendizaje y repaso de los comandos
    más importantes y más ampliamente utilizados de Git. Esta guía está organizada en 
    apartados que agrupan los diferentes tipos de tareas a realizar, y que muestran las 
    opciones y comandos habitualmente utilizados para llevar a cabo dichas tareas comunes. 
    </p>
    <p>
    Cada apartado contendrá un enlace al subsiguiente apartado, de forma que la guía pueda 
    ser utilizada como un tutorial. Cada página también incluirá enlaces a documentación 
    más exhaustiva de Git, tales como las páginas correspondientes del manual oficial de
    Git o apartados relevantes del libro  <a href="http://progit.org">Pro Git</a>, para 
    que se pueda ampliar el estudio de cualquiera de los comandos. En primer lugar
    empezaremos con unas reflexiones sobre cómo realiza Git la gestión del código fuente.
    </p>
  </div>
</div>

<div class="box">
  <h2>Cómo pensar como Git</h2>
  <div class="block">
    <p>
    El primer concepto que es importante  entender acerca de Git es que su forma de pensar
    sobre el control de versiones es muy diferente a como lo hace Subversion, Perforce o 
    cualquier otro SCM que se pueda estar usando. En general es más fácil aprender Git si 
    intentamos olvidar todas nuestras suposiciones previas sobre como funciona el control
    de versiones y tratar de pensar de la misma forma que lo hace Git.
    </p>
       
		<p>
    Vamos a empezar desde cero. Supongamos que estamos diseñando un nuevo sistema de 
    gestión de código fuente. ¿Cómo realizábamos el control de versiones antes de que
    usaramos herramientas para esto? Es bastante probable que simplemente nos limitemos
    a hacer una copia del directorio completo de nuestro proyecto, para salvaguardar
    lo que tengamos en este punto del desarrollo.
    </p>
       
    <pre> $ cp -R project project.bak </pre>
    
    <p>
    De esta forma podremos revertir fácilmente cualquier  fichero que más tarde
    hayamos arruinado, o podremos examinar los cambios que hemos realizado mediante
    la comparación del estado actual del proyecto con el estado que mostraba en el
    momento de la copia. 
    </p>

    <p>
    Si somos realmente paranoicos, podríamos hacer esta copia de forma periódica, 
    incluso añadiendo la fecha al nombre de cada copia de seguridad:
    </p>

    <pre> $ cp -R project project.2010-06-01.bak </pre>

    <p>
    En ese caso, es posible que acumulemos un montón de imágenes del proyecto (snapshots) 
    desde las que se pueden realizar tareas de inspección y comparación. Podríamos incluso 
    usar este modelo como una forma bastante eficaz de compartir cambios con otra gente. Si
    empaquetamos el proyecto en un estado concreto y lo publicamos en nuestro sitio web, otros
    desarrolladores pueden descargarselo, modificarlo y enviarnos de vuelta un parche de una
    forma bastante sencilla.
    </p>

<pre>
 $ wget http://sample.com/project.2010-06-01.zip
 $ unzip project.2010-06-01.zip
 $ cp -R project.2010-06-01 project-my-copy
 $ cd project-my-copy
 $ (change something)
 $ diff project-my-copy project.2010-06-01 > change.patch
 $ (email change.patch)
</pre>

    <p>
    Ahora el desarrollador inicial puede aplicar este parche a su copia del proyecto y así 
    conseguir los cambios realizados. <b>Esta es precisamente la forma en la que muchos
    proyectos open source han estado colaborando durante años.</b>
    </p>

    <p>
    Lo cierto es que este sistema funciona bastante bien, así que digamos que queremos crear 
    una herramienta que realice este proceso básico de una forma más rápida y  sencilla. En
    lugar de crear una herramienta que versione cada fichero de forma individual, como  hace 
    Subversion, seguramente inventaríamos una herramienta que permitiera crear y almacenar 
    de forma mas sencilla las instantáneas de nuestro proyecto (snaphots), sin necesidad de 
    copiar el directorio completo cada vez.
    </p>

    <p>
    Esto es lo que fundamentalmente hace Git. Le decimos a Git que queremos guardar
    un snapshot de nuestro proyecto usando  el comando <code>git commit</code> y
    básicamente graba un manifiesto o declaración del estado que muestran todos los
    ficheros del proyecto en ese punto. La mayoría de los comandos trabajan con estos
    manifiestos para ver en qué difieren unos de otros, extraer el contenido de éstos, etc.  
    </p>

    <center><img src="./images/snapshots.png"/></center>

    <p>
      <b>Si piensas en Git como una herramienta para almacenar, comparar y mezclar instantáneas
      de tu proyecto (snapshots)</b>, será más fácil entender lo que está sucediendo realmente y
      como hacer las cosas de la manera más apropiada.
    </p> 

  </div>
</div>

<p><a href="./es/creating">Sobre Obtener y Crear Proyectos &#187;</a></p>
